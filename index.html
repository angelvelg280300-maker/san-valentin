<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Para ti ‚ù§Ô∏è</title>
  <style>
    :root{ --bg:#f6f0e7; --card:#fff8ef; --text:#2a2a2a; --muted:#5a5a5a; }
    *{box-sizing:border-box}
    body{
      margin:0; min-height:100svh; display:grid; place-items:center; padding:18px;
      background: linear-gradient(180deg, #2b0036, #130018);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    .frame{
      width:min(980px,96vw); border-radius:26px; padding:16px;
      background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12);
      backdrop-filter:blur(10px);
    }
    .card{
      background:var(--card); border-radius:22px; overflow:hidden;
      box-shadow:0 24px 80px rgba(0,0,0,.35);
    }
    .content{ display:grid; grid-template-columns:1.1fr 1fr; min-height:520px; }
    .left{ padding:32px 26px 18px; color:var(--text); }
    .left h1{ font-size:18px; font-weight:700; margin:0 0 18px; }
    .poem{ font-size:22px; line-height:1.35; margin:0 0 16px; white-space:pre-line; }
    .sig{ margin-top:10px; font-size:20px; font-weight:650; }
    .divider{ height:1px; background:rgba(0,0,0,.2); margin:16px 0 14px; }
    .timerLabel{ font-size:18px; color:var(--muted); margin:0 0 6px; }
    .timer{ font-size:34px; font-weight:800; letter-spacing:.3px; }
    .timer small{ font-size:16px; font-weight:650; color:var(--muted); margin-right:6px; }
    .right{ background:var(--bg); display:grid; place-items:center; padding:12px; }
    canvas{
      width:100%; max-width:420px; height:100%; max-height:520px; aspect-ratio:4/5;
      border-radius:18px; background:linear-gradient(180deg,#f7f0e7,#f2e7db);
      border:1px solid rgba(0,0,0,.12);
    }
    .bottomBar{ height:6px; background:rgba(0,0,0,.08); }
    @media (max-width:860px){
      .content{grid-template-columns:1fr;}
      .poem{font-size:20px;}
      .timer{font-size:30px;}
    }
  </style>
</head>
<body>
  <div class="frame">
    <div class="card">
      <div class="content">
        <div class="left">
          <h1 id="title">Para el amor de mi vida:</h1>

          <div class="poem" id="poem">Si pudiera elegir un lugar
seguro, ser√≠a a tu lado.

Cuanto m√°s tiempo estoy
contigo m√°s enamorado de ti ü•∞</div>

          <div class="sig" id="sig">‚Äî Te amo ‚ù§Ô∏è</div>

          <div class="divider"></div>

          <div class="timerLabel">Mi amor por ti comenz√≥ hace‚Ä¶</div>
          <div class="timer">
            <span id="days">0</span> <small>d√≠as</small>
            <span id="hours">00</span> <small>horas</small>
            <span id="mins">00</span> <small>min</small>
            <span id="secs">00</span> <small>seg</small>
          </div>
        </div>

        <div class="right">
          <canvas id="c"></canvas>
        </div>
      </div>
      <div class="bottomBar"></div>
    </div>
  </div>

<script>
/* =========================
   CONFIG
   ========================= */
const CONFIG = {
  nombrePareja: "Metztli Rebeca Guadarrama Reyes",

  // 11/08/2024 (dd/mm/yyyy) = 11 de agosto 2024
  inicio: { y: 2024, m: 8, d: 11, hh: 0, mm: 0, ss: 0 },

  // Animaciones
  trunkGrowMs: 950,
  canopyStartMs: 420,
  canopyFillMs: 2200,

  // Copa (m√°s relleno y micro-corazones para tapar huecos)
  fillHearts: 2600,
  microHearts: 900,
  outlineHearts: 420,

  heartSizeMin: 10,
  heartSizeMax: 34,
  microMin: 6,
  microMax: 12,
  outlineSizeMin: 12,
  outlineSizeMax: 22,

  // Hojas cayendo
  fallingCount: 65,
  fallingMin: 10,
  fallingMax: 18,
};

/* =========================
   Textos
   ========================= */
document.getElementById("title").textContent =
  `Para el amor de mi vida, ${CONFIG.nombrePareja}:`;
document.getElementById("sig").textContent = "‚Äî Te amo ‚ù§Ô∏è";

/* =========================
   Contador (sin ambig√ºedad)
   ========================= */
const startDate = new Date(
  CONFIG.inicio.y, CONFIG.inicio.m - 1, CONFIG.inicio.d,
  CONFIG.inicio.hh, CONFIG.inicio.mm, CONFIG.inicio.ss
);
const elDays = document.getElementById("days");
const elHours = document.getElementById("hours");
const elMins = document.getElementById("mins");
const elSecs = document.getElementById("secs");

function tickTimer(){
  const now = new Date();
  const diffMs = Math.max(0, now - startDate);
  const totalSec = Math.floor(diffMs / 1000);
  const days = Math.floor(totalSec / 86400);
  const hours = Math.floor((totalSec % 86400) / 3600);
  const mins  = Math.floor((totalSec % 3600) / 60);
  const secs  = totalSec % 60;
  elDays.textContent = String(days);
  elHours.textContent = String(hours).padStart(2,"0");
  elMins.textContent  = String(mins).padStart(2,"0");
  elSecs.textContent  = String(secs).padStart(2,"0");
}
tickTimer();
setInterval(tickTimer, 1000);

/* =========================
   Canvas
   ========================= */
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

function resize(){
  const dpr = Math.min(2, window.devicePixelRatio || 1);
  const cssW = canvas.getBoundingClientRect().width;
  const cssH = canvas.getBoundingClientRect().height;
  canvas.width  = Math.floor(cssW * dpr);
  canvas.height = Math.floor(cssH * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
resize();

/* =========================
   Helpers + RNG estable
   ========================= */
function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }
function easeOutBack(t){
  const c1=1.70158, c3=c1+1;
  return 1 + c3*Math.pow(t-1,3) + c1*Math.pow(t-1,2);
}
function xfnv1a(str){
  let h = 2166136261 >>> 0;
  for (let i=0;i<str.length;i++){
    h ^= str.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return h >>> 0;
}
function mulberry32(a){
  return function(){
    let t = a += 0x6D2B79F5;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}
const rand = mulberry32(xfnv1a(`${CONFIG.nombrePareja}|${CONFIG.inicio.y}-${CONFIG.inicio.m}-${CONFIG.inicio.d}`));

/* =========================
   M√°scara coraz√≥n
   ========================= */
function heartMask(u, v){
  const x=u, y=v;
  const a = (x*x + y*y - 1);
  return (a*a*a - x*x*y*y*y) <= 0;
}

/* =========================
   Copa + mezcla de tonos
   ========================= */
let CAN = { cx:0, cy:0, R:1 };
const canopy = []; // {x,y,size,rot,alpha,appear,tone}

function heartCurve(t){
  const s = Math.sin(t), c = Math.cos(t);
  const x = 16*s*s*s;
  const y = 13*c - 5*Math.cos(2*t) - 2*Math.cos(3*t) - Math.cos(4*t);
  return {x, y};
}

// Mezcla suave (nada de ‚Äúmitades‚Äù): tonos se reparten con pesos por posici√≥n + random.
function pickToneMixed(u, v){
  // u,v aprox [-1.2,1.2] dentro del coraz√≥n
  // Pesos base
  let wR = 0.46, wP = 0.44, wW = 0.10;

  // Peque√±os sesgos (muy suaves)
  wR += (-u) * 0.10 + (v) * 0.06;          // un poquito m√°s rojo a la izquierda/abajo
  wP += ( u) * 0.10 + (v) * 0.04;          // un poquito m√°s rosa a la derecha/abajo
  wW += (1 - Math.abs(u)) * 0.10 + (-v)*0.04; // blanco m√°s hacia el centro y un poco arriba

  // Normalizar
  wR = Math.max(0.05, wR);
  wP = Math.max(0.05, wP);
  wW = Math.max(0.04, wW);

  const sum = wR + wP + wW;
  wR/=sum; wP/=sum; wW/=sum;

  const r = rand();
  if (r < wR) return 0;           // rojo
  if (r < wR + wP) return 1;      // rosa
  return 2;                        // blanco/crema
}

function buildCanopy(){
  canopy.length = 0;

  const W = canvas.getBoundingClientRect().width;
  const H = canvas.getBoundingClientRect().height;

  CAN.cx = W * 0.52;
  CAN.cy = H * 0.37;
  CAN.R  = Math.min(W, H) * 0.35;

  const start = CONFIG.canopyStartMs;

  // Contorno (borde fino)
  for (let i=0;i<CONFIG.outlineHearts;i++){
    const t = (i / CONFIG.outlineHearts) * Math.PI * 2;
    const p = heartCurve(t);

    const u = (p.x / 18) + (rand()*0.05 - 0.025);
    const v = (p.y / 18) + (rand()*0.05 - 0.025);

    const x = CAN.cx + u * CAN.R;
    const y = CAN.cy - v * CAN.R;

    canopy.push({
      x, y,
      size: CONFIG.outlineSizeMin + rand()*(CONFIG.outlineSizeMax - CONFIG.outlineSizeMin),
      rot: (rand()*0.9 - 0.45),
      tone: pickToneMixed(u, -v),
      alpha: 0.92,
      appear: start + rand()*CONFIG.canopyFillMs
    });
  }

  // Relleno principal (muchos)
  for (let i=0;i<CONFIG.fillHearts;i++){
    let u=0, v=0, tries=0;
    do{
      u = (rand()*2.4 - 1.2);
      v = (rand()*2.4 - 1.2);
      tries++;
    } while(!heartMask(u, -v) && tries < 120);

    const x = CAN.cx + u * CAN.R * 0.99;
    const y = CAN.cy + v * CAN.R * 0.99;

    const rr = rand();
    const size = CONFIG.heartSizeMin + (CONFIG.heartSizeMax - CONFIG.heartSizeMin) * (rr*rr);

    const tone = pickToneMixed(u, v);

    // Si es blanco, lo hacemos m√°s "crema" y menos intenso para que NO se lea como hueco
    const alpha = (tone === 2) ? (0.62 + rand()*0.18) : (0.76 + rand()*0.22);

    canopy.push({
      x, y,
      size,
      rot: (rand()*1.2 - 0.6),
      tone,
      alpha,
      appear: start + rand()*CONFIG.canopyFillMs
    });
  }

  // Micro-corazones (tapan huecos s√≠ o s√≠)
  for (let i=0;i<CONFIG.microHearts;i++){
    let u=0, v=0, tries=0;
    do{
      u = (rand()*2.4 - 1.2);
      v = (rand()*2.4 - 1.2);
      tries++;
    } while(!heartMask(u, -v) && tries < 120);

    const x = CAN.cx + u * CAN.R * 1.00;
    const y = CAN.cy + v * CAN.R * 1.00;

    // Micro casi siempre rojo/rosa, muy poco blanco (para que el blanco no parezca hueco)
    let tone = pickToneMixed(u, v);
    if (tone === 2 && rand() < 0.78) tone = (rand() < 0.5 ? 0 : 1);

    canopy.push({
      x, y,
      size: CONFIG.microMin + rand()*(CONFIG.microMax - CONFIG.microMin),
      rot: (rand()*1.6 - 0.8),
      tone,
      alpha: 0.55 + rand()*0.30,
      appear: start + rand()*CONFIG.canopyFillMs
    });
  }

  // Grandes primero, peque√±os al final (rellena mejor visualmente)
  canopy.sort((a,b) => b.size - a.size);
}

/* =========================
   Estilos de color (3 tonos mezclados)
   ========================= */
function heartFillStyle(tone, size){
  const g = ctx.createLinearGradient(-size, -size, size, size);

  if (tone === 0){
    // rojo
    g.addColorStop(0, "rgba(210, 18, 40, 0.96)");
    g.addColorStop(1, "rgba(255, 130, 130, 0.92)");
  } else if (tone === 1){
    // rosa
    g.addColorStop(0, "rgba(255, 70, 150, 0.92)");
    g.addColorStop(1, "rgba(255, 175, 215, 0.92)");
  } else {
    // blanco crema (NO puro, para que no parezca hueco)
    g.addColorStop(0, "rgba(255, 248, 252, 0.95)");
    g.addColorStop(1, "rgba(255, 230, 242, 0.92)");
  }
  return g;
}

function drawHeartPx(x, y, wPx, alpha, rot, tone){
  const s = wPx / 3.2;

  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.translate(x,y);
  ctx.rotate(rot);
  ctx.scale(s, s);

  ctx.fillStyle = heartFillStyle(tone, 2.2);

  ctx.beginPath();
  ctx.moveTo(0, -0.35);
  ctx.bezierCurveTo(0.7, -1.15, 1.6, -0.25, 0, 1.0);
  ctx.bezierCurveTo(-1.6, -0.25, -0.7, -1.15, 0, -0.35);
  ctx.closePath();
  ctx.fill();

  // contorno ultra sutil para que el ‚Äúblanco‚Äù no se pierda con el fondo
  ctx.globalAlpha = alpha * 0.18;
  ctx.lineWidth = 0.10;
  ctx.strokeStyle = "rgba(180, 60, 110, 1)";
  ctx.stroke();

  ctx.restore();
}

/* =========================
   Silueta suave detr√°s (evita ‚Äúhuecos‚Äù visuales)
   ========================= */
function drawSoftSilhouette(){
  // Una capa MUY ligera, del tama√±o de la copa,
  // para que aunque haya espacios, nunca se sienta vac√≠o.
  const size = CAN.R * 1.55; // pix aprox
  const x = CAN.cx;
  const y = CAN.cy + CAN.R*0.06;
  ctx.save();
  ctx.globalAlpha = 0.10;
  drawHeartPx(x, y, size, 0.10, 0, 1); // tono rosa muy suave
  ctx.restore();
}

/* =========================
   Tronco (m√°s largo)
   ========================= */
function drawTrunkBase(t){
  const W = canvas.getBoundingClientRect().width;
  const H = canvas.getBoundingClientRect().height;

  const p = clamp(t / CONFIG.trunkGrowMs, 0, 1);
  const e = easeOutCubic(p);

  const baseX = W * 0.52;
  const baseY = H * 0.93;

  // M√ÅS LARGO (antes estaba muy corto)
  const topY  = H * 0.60;
  const y = baseY - (baseY - topY) * e;

  ctx.save();
  ctx.globalAlpha = 0.06;
  ctx.fillStyle = "#000";
  ctx.beginPath();
  ctx.ellipse(baseX, baseY + 4, W*0.22, H*0.03, 0, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();

  const trunkWBottom = W * 0.072;
  const trunkWTop    = W * 0.044;

  const grad = ctx.createLinearGradient(baseX - trunkWBottom, y, baseX + trunkWBottom, baseY);
  grad.addColorStop(0, "rgba(92,59,40,0.92)");
  grad.addColorStop(1, "rgba(145,98,68,0.90)");
  ctx.fillStyle = grad;

  ctx.beginPath();
  ctx.moveTo(baseX - trunkWBottom/2, baseY);
  ctx.lineTo(baseX + trunkWBottom/2, baseY);
  ctx.lineTo(baseX + trunkWTop/2, y);
  ctx.lineTo(baseX - trunkWTop/2, y);
  ctx.closePath();
  ctx.fill();
}

/* =========================
   Hojas cayendo (corazones)
   ========================= */
const falling = [];

function spawnFalling(p){
  const W = canvas.getBoundingClientRect().width;
  const H = canvas.getBoundingClientRect().height;

  let u=0, v=0, tries=0;
  do{
    u = (rand()*2.4 - 1.2);
    v = (rand()*2.4 - 1.2);
    tries++;
  } while(!heartMask(u, -v) && tries < 120);

  p.x0 = CAN.cx + u * CAN.R * 0.95;
  p.y  = CAN.cy + v * CAN.R * 0.95 + (rand()*18 - 9);

  p.vy = 35 + rand()*70;
  p.amp = 10 + rand()*18;
  p.freq = 1.1 + rand()*1.8;
  p.phase = rand()*Math.PI*2;
  p.rot = rand()*Math.PI*2;
  p.rotSpd = (rand()*1.6 - 0.8);
  p.size = CONFIG.fallingMin + rand()*(CONFIG.fallingMax - CONFIG.fallingMin);

  // tonos mezclados tambi√©n en ca√≠da
  p.tone = pickToneMixed(u, v);
  if (p.tone === 2 && rand() < 0.55) p.tone = (rand() < 0.5 ? 0 : 1);

  p.alpha = 0.55 + rand()*0.30;

  if (rand() < 0.22) p.y = CAN.cy - CAN.R * 0.65 + rand()*30;
}

function buildFalling(){
  falling.length = 0;
  for (let i=0;i<CONFIG.fallingCount;i++){
    const p = {};
    spawnFalling(p);
    p.y += rand()*240;
    falling.push(p);
  }
}

/* =========================
   Build
   ========================= */
function buildAll(){
  resize();
  buildCanopy();
  buildFalling();
}
buildAll();

window.addEventListener("resize", buildAll);
window.addEventListener("orientationchange", () => setTimeout(buildAll, 120));

/* =========================
   Loop
   ========================= */
let last = performance.now();
const t0 = performance.now();

function loop(now){
  const t = now - t0;
  const dt = Math.min(0.033, (now - last) / 1000);
  last = now;

  const W = canvas.getBoundingClientRect().width;
  const H = canvas.getBoundingClientRect().height;

  ctx.clearRect(0,0,W,H);

  // tronco
  drawTrunkBase(t);

  // silueta suave detr√°s (evita huecos visuales)
  if (t > 80) drawSoftSilhouette();

  // copa
  for (const c of canopy){
    const lt = clamp((t - c.appear) / 850, 0, 1);
    if (lt <= 0) continue;

    const pop = easeOutBack(lt);
    const a = c.alpha * clamp(lt*1.25, 0, 1);
    const size = c.size * (0.30 + 0.70*pop);

    drawHeartPx(c.x, c.y, size, a, c.rot, c.tone);
  }

  // ca√≠da
  if (t > CONFIG.canopyStartMs + 300){
    for (const p of falling){
      p.y += p.vy * dt;
      const x = p.x0 + Math.sin((now/1000)*Math.PI*2*p.freq + p.phase) * p.amp;
      p.rot += p.rotSpd * dt;

      let a = p.alpha;
      if (p.y > H*0.82) a *= clamp(1 - (p.y - H*0.82)/(H*0.25), 0, 1);

      drawHeartPx(x, p.y, p.size, a, p.rot, p.tone);

      if (p.y > H + 30) spawnFalling(p);
    }
  }

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
