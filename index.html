<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Para ti ❤️</title>
  <style>
    :root{ --bg:#f6f0e7; --card:#fff8ef; --text:#2a2a2a; --muted:#5a5a5a; }
    *{box-sizing:border-box}
    body{
      margin:0; min-height:100svh; display:grid; place-items:center; padding:18px;
      background: linear-gradient(180deg, #2b0036, #130018);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    .frame{
      width:min(980px,96vw); border-radius:26px; padding:16px;
      background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12);
      backdrop-filter:blur(10px);
    }
    .card{
      background:var(--card); border-radius:22px; overflow:hidden;
      box-shadow:0 24px 80px rgba(0,0,0,.35);
    }
    .content{ display:grid; grid-template-columns:1.1fr 1fr; min-height:520px; }
    .left{ padding:32px 26px 18px; color:var(--text); }
    .left h1{ font-size:18px; font-weight:700; margin:0 0 18px; }
    .poem{ font-size:22px; line-height:1.35; margin:0 0 16px; white-space:pre-line; }
    .sig{ margin-top:10px; font-size:20px; font-weight:650; }
    .divider{ height:1px; background:rgba(0,0,0,.2); margin:16px 0 14px; }
    .timerLabel{ font-size:18px; color:var(--muted); margin:0 0 6px; }
    .timer{ font-size:34px; font-weight:800; letter-spacing:.3px; }
    .timer small{ font-size:16px; font-weight:650; color:var(--muted); margin-right:6px; }
    .right{ background:var(--bg); display:grid; place-items:center; padding:12px; }
    canvas{
      width:100%; max-width:420px; height:100%; max-height:520px; aspect-ratio:4/5;
      border-radius:18px; background:linear-gradient(180deg,#f7f0e7,#f2e7db);
      border:1px solid rgba(0,0,0,.12);
    }
    .bottomBar{ height:6px; background:rgba(0,0,0,.08); }
    @media (max-width:860px){
      .content{grid-template-columns:1fr;}
      .poem{font-size:20px;}
      .timer{font-size:30px;}
    }
  </style>
</head>
<body>
  <div class="frame">
    <div class="card">
      <div class="content">
        <div class="left">
          <h1 id="title">Para el amor de mi vida:</h1>

          <div class="poem" id="poem">Si pudiera elegir un lugar
seguro, sería a tu lado.

Cuanto más tiempo estoy
contigo más te amo.</div>

          <div class="sig" id="sig">— Te amo ❤️</div>

          <div class="divider"></div>

          <div class="timerLabel">Mi amor por ti comenzó hace…</div>
          <div class="timer">
            <span id="days">0</span> <small>días</small>
            <span id="hours">00</span> <small>horas</small>
            <span id="mins">00</span> <small>min</small>
            <span id="secs">00</span> <small>seg</small>
          </div>
        </div>

        <div class="right">
          <canvas id="c"></canvas>
        </div>
      </div>
      <div class="bottomBar"></div>
    </div>
  </div>

<script>
/* =========================
   CONFIG
   ========================= */
const CONFIG = {
  nombrePareja: "Metztli Rebeca Guadarrama Reyes",

  // 11/08/2024 (dd/mm/yyyy) = 11 de agosto 2024
  inicio: { y: 2024, m: 8, d: 11, hh: 0, mm: 0, ss: 0 },

  // Animación
  growMs: 2000,          // ramas (rápido)
  canopyStartMs: 1200,   // corazones empiezan pronto
  canopyFillMs: 2200,    // se completa la copa

  // Copa (más densa, menos huecos)
  fillHearts: 1250,      // relleno (muchos)
  outlineHearts: 260,    // contorno (borde más fino)
  heartSizeMin: 16,      // px
  heartSizeMax: 34,      // px
  outlineSizeMin: 14,    // px
  outlineSizeMax: 24,    // px

  // Ramas (de fondo)
  branchAlphaBefore: 0.55,
  branchAlphaAfter: 0.08,    // MUY tenue
};

/* =========================
   Textos
   ========================= */
document.getElementById("title").textContent =
  `Para el amor de mi vida, ${CONFIG.nombrePareja}:`;
document.getElementById("sig").textContent = "— Te amo ❤️";

/* =========================
   Contador (sin ambigüedad)
   ========================= */
const startDate = new Date(
  CONFIG.inicio.y, CONFIG.inicio.m - 1, CONFIG.inicio.d,
  CONFIG.inicio.hh, CONFIG.inicio.mm, CONFIG.inicio.ss
);
const elDays = document.getElementById("days");
const elHours = document.getElementById("hours");
const elMins = document.getElementById("mins");
const elSecs = document.getElementById("secs");

function tickTimer(){
  const now = new Date();
  const diffMs = Math.max(0, now - startDate);
  const totalSec = Math.floor(diffMs / 1000);

  const days = Math.floor(totalSec / 86400);
  const hours = Math.floor((totalSec % 86400) / 3600);
  const mins  = Math.floor((totalSec % 3600) / 60);
  const secs  = totalSec % 60;

  elDays.textContent = String(days);
  elHours.textContent = String(hours).padStart(2,"0");
  elMins.textContent  = String(mins).padStart(2,"0");
  elSecs.textContent  = String(secs).padStart(2,"0");
}
tickTimer();
setInterval(tickTimer, 1000);

/* =========================
   Canvas
   ========================= */
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

function resize(){
  const dpr = Math.min(2, window.devicePixelRatio || 1);
  const cssW = canvas.getBoundingClientRect().width;
  const cssH = canvas.getBoundingClientRect().height;
  canvas.width  = Math.floor(cssW * dpr);
  canvas.height = Math.floor(cssH * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0); // dibujar en px CSS
}
resize();

/* =========================
   Helpers + RNG estable
   ========================= */
function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }
function easeOutBack(t){
  const c1=1.70158, c3=c1+1;
  return 1 + c3*Math.pow(t-1,3) + c1*Math.pow(t-1,2);
}
function xfnv1a(str){
  let h = 2166136261 >>> 0;
  for (let i=0;i<str.length;i++){
    h ^= str.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return h >>> 0;
}
function mulberry32(a){
  return function(){
    let t = a += 0x6D2B79F5;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}
const rand = mulberry32(xfnv1a(`${CONFIG.nombrePareja}|${CONFIG.inicio.y}-${CONFIG.inicio.m}-${CONFIG.inicio.d}`));

/* =========================
   Máscara corazón (para:
   1) poner corazones
   2) RECORTAR ramas de afuera)
   ========================= */
function heartMask(u, v){
  // (x^2 + y^2 - 1)^3 - x^2 y^3 <= 0
  const x=u, y=v;
  const a = (x*x + y*y - 1);
  return (a*a*a - x*x*y*y*y) <= 0;
}

/* =========================
   Geometría global (se calcula en buildAll)
   ========================= */
let CAN = { cx:0, cy:0, R:1 }; // centro y radio de copa

function insideCanopy(x, y, inflate=1.10){
  // Convertimos a coords normalizadas del corazón
  const u = (x - CAN.cx) / (CAN.R * inflate);
  const v = (y - CAN.cy) / (CAN.R * inflate);
  return heartMask(u, -v); // invertimos v para orientar bien
}

/* =========================
   Árbol (ramas) - pero luego recortamos
   ========================= */
const segments = [];

function addBranch(x1,y1, angle, length, thickness, depth, maxDepth){
  const x2 = x1 + Math.cos(angle) * length;
  const y2 = y1 + Math.sin(angle) * length;

  segments.push({x1,y1,x2,y2, thickness, rs:0, re:0});

  if (depth >= maxDepth || length < 18) return;

  const branches = (rand() < 0.25) ? 3 : 2;
  for (let i=0;i<branches;i++){
    const spread = (branches===3) ? (i-1) : (i===0 ? -1 : 1);

    // Menos apertura para que no se vayan hacia los lados
    const a2 = angle + spread*(0.45 + rand()*0.18) + (rand()*0.22 - 0.11);
    const l2 = length * (0.72 + rand()*0.10);
    const th2 = thickness * (0.72 + rand()*0.10);

    addBranch(x2, y2, a2, l2, th2, depth+1, maxDepth);
  }
}

function buildBranches(){
  segments.length = 0;
  const W = canvas.getBoundingClientRect().width;
  const H = canvas.getBoundingClientRect().height;

  const rootX = W * 0.52;
  const rootY = H * 0.92;

  // tronco + ramaje
  addBranch(rootX, rootY, -Math.PI/2, H*0.23, 14, 0, 6);

  // tiempos de crecimiento
  const total = segments.length;
  for (let i=0;i<total;i++){
    const start = (i / total) * CONFIG.growMs;
    segments[i].rs = start;
    segments[i].re = start + (340 + rand()*220);
  }
}

/* =========================
   Corazones (relleno + contorno)
   ========================= */
const canopy = []; // {x,y,size,rot,hue,alpha,appear}

function heartCurve(t){
  // Curva clásica de corazón (x,y)
  // x = 16 sin^3 t
  // y = 13 cos t - 5 cos 2t - 2 cos 3t - cos 4t
  const s = Math.sin(t);
  const c = Math.cos(t);
  const x = 16 * s*s*s;
  const y = 13*c - 5*Math.cos(2*t) - 2*Math.cos(3*t) - Math.cos(4*t);
  return {x, y};
}

function buildCanopy(){
  canopy.length = 0;
  const W = canvas.getBoundingClientRect().width;
  const H = canvas.getBoundingClientRect().height;

  // Centro de copa (ajustado para quedar bonito)
  CAN.cx = W * 0.52;
  CAN.cy = H * 0.36;
  CAN.R  = Math.min(W, H) * 0.34;

  const start = CONFIG.canopyStartMs;

  // 1) CONTORNO: para borde fino y definido
  // Normalizamos la curva (porque sus valores son grandes)
  // En práctica: dividimos por ~18 para quedar en [-1.2,1.2] aprox
  for (let i=0;i<CONFIG.outlineHearts;i++){
    const t = (i / CONFIG.outlineHearts) * Math.PI * 2;
    const p = heartCurve(t);

    // Normalización + ligero jitter para que se vea orgánico
    const u = (p.x / 18) + (rand()*0.06 - 0.03);
    const v = (p.y / 18) + (rand()*0.06 - 0.03);

    const x = CAN.cx + u * CAN.R;
    const y = CAN.cy - v * CAN.R; // invertimos para orientación

    const size = CONFIG.outlineSizeMin + rand()*(CONFIG.outlineSizeMax - CONFIG.outlineSizeMin);
    canopy.push({
      x, y,
      size,
      rot: (rand()*0.9 - 0.45),
      hue: Math.floor(rand()*18) - 9,
      alpha: 0.92,
      appear: start + rand()*CONFIG.canopyFillMs
    });
  }

  // 2) RELLENO: muchos corazones dentro de la máscara (para quitar huecos)
  for (let i=0;i<CONFIG.fillHearts;i++){
    let u=0, v=0, tries=0;
    do{
      u = (rand()*2.4 - 1.2);
      v = (rand()*2.4 - 1.2);
      tries++;
    } while(!heartMask(u, -v) && tries < 60);

    // Un pelín más compactos para que se vea lleno
    const x = CAN.cx + u * CAN.R * 0.98;
    const y = CAN.cy + v * CAN.R * 0.98;

    // Bias: muchos medianos + algunos pequeños para tapar huecos
    const r = rand();
    const base = CONFIG.heartSizeMin + (CONFIG.heartSizeMax - CONFIG.heartSizeMin) * (r*r);

    canopy.push({
      x, y,
      size: base,
      rot: (rand()*1.2 - 0.6),
      hue: Math.floor(rand()*26) - 13,
      alpha: 0.78 + rand()*0.22,
      appear: start + rand()*CONFIG.canopyFillMs
    });
  }

  // Para que se rellene mejor: dibujamos primero grandes y al final pequeños
  canopy.sort((a,b) => b.size - a.size);
}

/* =========================
   Dibujo corazón (tamaño en pixeles)
   ========================= */
function drawHeartPx(x, y, wPx, alpha, rot, hueShift){
  // Path ~ 3.2 unidades de ancho -> convertimos a escala
  const s = wPx / 3.2;

  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.translate(x,y);
  ctx.rotate(rot);
  ctx.scale(s, s);

  const g = ctx.createLinearGradient(-1.2,-1.2, 1.2, 1.2);
  g.addColorStop(0, `hsl(${345+hueShift}, 92%, 56%)`);
  g.addColorStop(1, `hsl(${356+hueShift}, 96%, 72%)`);
  ctx.fillStyle = g;

  ctx.beginPath();
  ctx.moveTo(0, -0.35);
  ctx.bezierCurveTo(0.7, -1.15, 1.6, -0.25, 0, 1.0);
  ctx.bezierCurveTo(-1.6, -0.25, -0.7, -1.15, 0, -0.35);
  ctx.closePath();
  ctx.fill();

  ctx.restore();
}

/* =========================
   Build + animación
   ========================= */
function buildAll(){
  resize();
  buildBranches();
  buildCanopy();
}
buildAll();

window.addEventListener("resize", buildAll);
window.addEventListener("orientationchange", () => setTimeout(buildAll, 150));

const t0 = performance.now();
function loop(now){
  const t = now - t0;
  const W = canvas.getBoundingClientRect().width;
  const H = canvas.getBoundingClientRect().height;

  ctx.clearRect(0,0,W,H);

  // sombra base
  ctx.save();
  ctx.globalAlpha = 0.06;
  ctx.fillStyle = "#000";
  ctx.beginPath();
  ctx.ellipse(W*0.52, H*0.94, W*0.22, H*0.03, 0, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();

  // RAMAS: recortadas para que NO salgan las laterales (las rojas)
  const branchAlpha = (t < CONFIG.canopyStartMs) ? CONFIG.branchAlphaBefore : CONFIG.branchAlphaAfter;

  for (const seg of segments){
    const local = clamp((t - seg.rs) / (seg.re - seg.rs), 0, 1);
    if (local <= 0) continue;

    const p = easeOutCubic(local);
    const x = seg.x1 + (seg.x2 - seg.x1) * p;
    const y = seg.y1 + (seg.y2 - seg.y1) * p;

    // Decide si se dibuja el segmento:
    // - Si está abajo (tronco) se dibuja
    // - Si está arriba, SOLO si cae dentro de la copa de corazón
    const midX = (seg.x1 + x) * 0.5;
    const midY = (seg.y1 + y) * 0.5;

    const isTrunkZone = (midY > CAN.cy + CAN.R * 0.35);
    const okInside = insideCanopy(midX, midY, 1.18);

    if (!isTrunkZone && !okInside) continue; // <-- AQUÍ “BORRAMOS” ramas laterales

    ctx.lineCap = "round";
    ctx.strokeStyle = `rgba(94,59,40,${branchAlpha})`;
    ctx.lineWidth = Math.max(1.2, seg.thickness) * (t < CONFIG.canopyStartMs ? 1.0 : 0.72);
    ctx.beginPath();
    ctx.moveTo(seg.x1, seg.y1);
    ctx.lineTo(x, y);
    ctx.stroke();
  }

  // CORAZONES: copa densa + borde fino (menos huecos)
  for (const c of canopy){
    const lt = clamp((t - c.appear) / 850, 0, 1);
    if (lt <= 0) continue;

    const pop = easeOutBack(lt);
    const a = c.alpha * clamp(lt*1.25, 0, 1);
    const size = c.size * (0.35 + 0.65*pop);

    drawHeartPx(c.x, c.y, size, a, c.rot, c.hue);
  }

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
