<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Para ti ❤️</title>
  <style>
    :root{ --bg:#f6f0e7; --card:#fff8ef; --text:#2a2a2a; --muted:#5a5a5a; }
    *{box-sizing:border-box}
    body{
      margin:0; min-height:100svh; display:grid; place-items:center; padding:18px;
      background: linear-gradient(180deg, #2b0036, #130018);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    .frame{
      width:min(980px,96vw); border-radius:26px; padding:16px;
      background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12);
      backdrop-filter:blur(10px);
    }
    .card{
      background:var(--card); border-radius:22px; overflow:hidden;
      box-shadow:0 24px 80px rgba(0,0,0,.35);
    }
    .content{ display:grid; grid-template-columns:1.1fr 1fr; min-height:520px; }
    .left{ padding:32px 26px 18px; color:var(--text); }
    .left h1{ font-size:18px; font-weight:700; margin:0 0 18px; }
    .poem{ font-size:22px; line-height:1.35; margin:0 0 16px; white-space:pre-line; }
    .sig{ margin-top:10px; font-size:20px; font-weight:650; }
    .divider{ height:1px; background:rgba(0,0,0,.2); margin:16px 0 14px; }
    .timerLabel{ font-size:18px; color:var(--muted); margin:0 0 6px; }
    .timer{ font-size:34px; font-weight:800; letter-spacing:.3px; }
    .timer small{ font-size:16px; font-weight:650; color:var(--muted); margin-right:6px; }

    .right{ background:var(--bg); display:grid; place-items:center; padding:12px; }
    canvas{
      width:100%; max-width:420px; height:100%; max-height:520px; aspect-ratio:4/5;
      border-radius:18px; background:linear-gradient(180deg,#f7f0e7,#f2e7db);
      border:1px solid rgba(0,0,0,.12);
    }
    .bottomBar{ height:6px; background:rgba(0,0,0,.08); }
    @media (max-width:860px){
      .content{grid-template-columns:1fr;}
      .poem{font-size:20px;}
      .timer{font-size:30px;}
    }
  </style>
</head>
<body>
  <div class="frame">
    <div class="card">
      <div class="content">
        <div class="left">
          <h1 id="title">Para el amor de mi vida:</h1>

          <div class="poem" id="poem">Si pudiera elegir un lugar
seguro, sería a tu lado.

Cuanto más tiempo estoy
contigo más te amo.</div>

          <div class="sig" id="sig">— Te amo ❤️</div>

          <div class="divider"></div>

          <div class="timerLabel">Mi amor por ti comenzó hace…</div>
          <div class="timer">
            <span id="days">0</span> <small>días</small>
            <span id="hours">00</span> <small>horas</small>
            <span id="mins">00</span> <small>min</small>
            <span id="secs">00</span> <small>seg</small>
          </div>
        </div>

        <div class="right">
          <canvas id="c"></canvas>
        </div>
      </div>
      <div class="bottomBar"></div>
    </div>
  </div>

<script>
/* =========================
   CONFIG
   ========================= */
const CONFIG = {
  nombrePareja: "Metztli Rebeca Guadarrama Reyes",

  // 11/08/2024 (dd/mm/yyyy) = 11 de agosto 2024
  inicio: { y: 2024, m: 8, d: 11, hh: 0, mm: 0, ss: 0 },

  // Animaciones
  trunkGrowMs: 900,       // aparece el tronco
  canopyStartMs: 450,     // empiezan a salir corazones
  canopyFillMs: 2000,     // se completa la copa

  // Copa (más relleno = menos huecos)
  fillHearts: 1700,
  outlineHearts: 380,
  heartSizeMin: 14,       // corazones pequeños tapan huecos
  heartSizeMax: 34,
  outlineSizeMin: 14,
  outlineSizeMax: 22,

  // Hojas cayendo
  fallingCount: 55,
  fallingMin: 10,
  fallingMax: 18,
};

/* =========================
   Textos
   ========================= */
document.getElementById("title").textContent =
  `Para el amor de mi vida, ${CONFIG.nombrePareja}:`;
document.getElementById("sig").textContent = "— Te amo ❤️";

/* =========================
   Contador (sin ambigüedad)
   ========================= */
const startDate = new Date(
  CONFIG.inicio.y, CONFIG.inicio.m - 1, CONFIG.inicio.d,
  CONFIG.inicio.hh, CONFIG.inicio.mm, CONFIG.inicio.ss
);

const elDays = document.getElementById("days");
const elHours = document.getElementById("hours");
const elMins = document.getElementById("mins");
const elSecs = document.getElementById("secs");

function tickTimer(){
  const now = new Date();
  const diffMs = Math.max(0, now - startDate);
  const totalSec = Math.floor(diffMs / 1000);

  const days = Math.floor(totalSec / 86400);
  const hours = Math.floor((totalSec % 86400) / 3600);
  const mins  = Math.floor((totalSec % 3600) / 60);
  const secs  = totalSec % 60;

  elDays.textContent = String(days);
  elHours.textContent = String(hours).padStart(2,"0");
  elMins.textContent  = String(mins).padStart(2,"0");
  elSecs.textContent  = String(secs).padStart(2,"0");
}
tickTimer();
setInterval(tickTimer, 1000);

/* =========================
   Canvas setup
   ========================= */
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

function resize(){
  const dpr = Math.min(2, window.devicePixelRatio || 1);
  const cssW = canvas.getBoundingClientRect().width;
  const cssH = canvas.getBoundingClientRect().height;
  canvas.width  = Math.floor(cssW * dpr);
  canvas.height = Math.floor(cssH * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0); // dibujar en px CSS
}
resize();

/* =========================
   Helpers + RNG estable
   ========================= */
function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }
function easeOutBack(t){
  const c1=1.70158, c3=c1+1;
  return 1 + c3*Math.pow(t-1,3) + c1*Math.pow(t-1,2);
}
function xfnv1a(str){
  let h = 2166136261 >>> 0;
  for (let i=0;i<str.length;i++){
    h ^= str.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return h >>> 0;
}
function mulberry32(a){
  return function(){
    let t = a += 0x6D2B79F5;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}
const rand = mulberry32(xfnv1a(`${CONFIG.nombrePareja}|${CONFIG.inicio.y}-${CONFIG.inicio.m}-${CONFIG.inicio.d}`));

/* =========================
   Máscara corazón
   ========================= */
function heartMask(u, v){
  // (x^2 + y^2 - 1)^3 - x^2 y^3 <= 0
  const x=u, y=v;
  const a = (x*x + y*y - 1);
  return (a*a*a - x*x*y*y*y) <= 0;
}

/* =========================
   Copa (corazón) + tonos
   ========================= */
let CAN = { cx:0, cy:0, R:1 };
const canopy = []; // {x,y,size,rot,alpha,appear, tone}

function heartCurve(t){
  // Curva clásica
  const s = Math.sin(t), c = Math.cos(t);
  const x = 16*s*s*s;
  const y = 13*c - 5*Math.cos(2*t) - 2*Math.cos(3*t) - Math.cos(4*t);
  return {x, y};
}

// tonos: rojo / rosa / blanco, "acomodados"
function pickTone(u, v){
  // u,v en [-1.2,1.2]
  // Zonas (para que se vean acomodados, no random total)
  // - Lado izquierdo y parte baja: más rojo
  // - Lado derecho: más rosa
  // - Centro/alto: toques blancos
  let tone;
  if (u < -0.20 || v > 0.35) tone = 0;         // rojo
  else if (u > 0.20) tone = 1;                 // rosa
  else tone = 2;                                // blanco

  // un poco de "mezcla" para que se vea natural
  const r = rand();
  if (tone === 0 && r < 0.10) tone = 1;
  else if (tone === 1 && r < 0.10) tone = 0;
  else if (tone !== 2 && r < 0.07) tone = 2;

  return tone; // 0 rojo, 1 rosa, 2 blanco
}

function buildCanopy(){
  canopy.length = 0;

  const W = canvas.getBoundingClientRect().width;
  const H = canvas.getBoundingClientRect().height;

  CAN.cx = W * 0.52;
  CAN.cy = H * 0.37;
  CAN.R  = Math.min(W, H) * 0.35;

  const start = CONFIG.canopyStartMs;

  // Contorno (borde más fino)
  for (let i=0;i<CONFIG.outlineHearts;i++){
    const t = (i / CONFIG.outlineHearts) * Math.PI * 2;
    const p = heartCurve(t);

    const u = (p.x / 18) + (rand()*0.05 - 0.025);
    const v = (p.y / 18) + (rand()*0.05 - 0.025);

    const x = CAN.cx + u * CAN.R;
    const y = CAN.cy - v * CAN.R;

    const tone = pickTone(u, -v);

    canopy.push({
      x, y,
      size: CONFIG.outlineSizeMin + rand()*(CONFIG.outlineSizeMax - CONFIG.outlineSizeMin),
      rot: (rand()*0.9 - 0.45),
      alpha: 0.95,
      appear: start + rand()*CONFIG.canopyFillMs,
      tone
    });
  }

  // Relleno (muchos)
  for (let i=0;i<CONFIG.fillHearts;i++){
    let u=0, v=0, tries=0;
    do{
      u = (rand()*2.4 - 1.2);
      v = (rand()*2.4 - 1.2);
      tries++;
    } while(!heartMask(u, -v) && tries < 80);

    const x = CAN.cx + u * CAN.R * 0.99;
    const y = CAN.cy + v * CAN.R * 0.99;

    const r = rand();
    const size = CONFIG.heartSizeMin + (CONFIG.heartSizeMax - CONFIG.heartSizeMin) * (r*r);

    const tone = pickTone(u, v);

    canopy.push({
      x, y,
      size,
      rot: (rand()*1.2 - 0.6),
      alpha: 0.78 + rand()*0.22,
      appear: start + rand()*CONFIG.canopyFillMs,
      tone
    });
  }

  // Grandes primero, pequeños al final (mejor “relleno”)
  canopy.sort((a,b) => b.size - a.size);
}

/* =========================
   Dibujo de corazón con 3 tonos
   ========================= */
function heartFillStyle(tone, x, y, size){
  // 0 rojo, 1 rosa, 2 blanco
  // Usamos un degradado suave para estilo “acuarela”
  const g = ctx.createLinearGradient(x - size, y - size, x + size, y + size);

  if (tone === 0){
    // rojo
    g.addColorStop(0, "rgba(216, 25, 45, 0.95)");
    g.addColorStop(1, "rgba(255, 120, 120, 0.92)");
  } else if (tone === 1){
    // rosa
    g.addColorStop(0, "rgba(255, 74, 150, 0.92)");
    g.addColorStop(1, "rgba(255, 170, 210, 0.92)");
  } else {
    // blanco/crema
    g.addColorStop(0, "rgba(255, 255, 255, 0.96)");
    g.addColorStop(1, "rgba(255, 232, 240, 0.94)");
  }
  return g;
}

function drawHeartPx(x, y, wPx, alpha, rot, tone){
  // Path ~ 3.2 unidades
  const s = wPx / 3.2;

  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.translate(x,y);
  ctx.rotate(rot);
  ctx.scale(s, s);

  ctx.fillStyle = heartFillStyle(tone, 0, 0, 2.0);

  ctx.beginPath();
  ctx.moveTo(0, -0.35);
  ctx.bezierCurveTo(0.7, -1.15, 1.6, -0.25, 0, 1.0);
  ctx.bezierCurveTo(-1.6, -0.25, -0.7, -1.15, 0, -0.35);
  ctx.closePath();
  ctx.fill();

  ctx.restore();
}

/* =========================
   Tronco (solo base)
   ========================= */
function drawTrunkBase(t){
  const W = canvas.getBoundingClientRect().width;
  const H = canvas.getBoundingClientRect().height;

  const p = clamp(t / CONFIG.trunkGrowMs, 0, 1);
  const e = easeOutCubic(p);

  const baseX = W * 0.52;
  const baseY = H * 0.93;
  const topY  = H * 0.73; // “solo un tramo” como base
  const y = baseY - (baseY - topY) * e;

  // sombra al piso
  ctx.save();
  ctx.globalAlpha = 0.06;
  ctx.fillStyle = "#000";
  ctx.beginPath();
  ctx.ellipse(baseX, baseY + 4, W*0.22, H*0.03, 0, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();

  // tronco (trapezoide) con leve degradado
  const trunkWBottom = W * 0.07;
  const trunkWTop    = W * 0.045;

  const grad = ctx.createLinearGradient(baseX - trunkWBottom, y, baseX + trunkWBottom, baseY);
  grad.addColorStop(0, "rgba(92,59,40,0.92)");
  grad.addColorStop(1, "rgba(140,92,62,0.88)");
  ctx.fillStyle = grad;

  ctx.beginPath();
  ctx.moveTo(baseX - trunkWBottom/2, baseY);
  ctx.lineTo(baseX + trunkWBottom/2, baseY);
  ctx.lineTo(baseX + trunkWTop/2, y);
  ctx.lineTo(baseX - trunkWTop/2, y);
  ctx.closePath();
  ctx.fill();
}

/* =========================
   Hojas cayendo (corazones)
   ========================= */
const falling = []; // partículas

function spawnFalling(p){
  const W = canvas.getBoundingClientRect().width;
  const H = canvas.getBoundingClientRect().height;

  // spawn dentro de la copa
  let u=0, v=0, tries=0;
  do{
    u = (rand()*2.4 - 1.2);
    v = (rand()*2.4 - 1.2);
    tries++;
  } while(!heartMask(u, -v) && tries < 80);

  const x0 = CAN.cx + u * CAN.R * 0.95;
  const y0 = CAN.cy + v * CAN.R * 0.95;

  p.x0 = x0;
  p.y = y0 + (rand()*20 - 10);
  p.vy = 35 + rand()*65;          // px/s
  p.amp = 10 + rand()*18;         // balanceo
  p.freq = 1.2 + rand()*1.6;      // Hz
  p.phase = rand()*Math.PI*2;
  p.rot = rand()*Math.PI*2;
  p.rotSpd = (rand()*1.6 - 0.8);  // rad/s
  p.size = CONFIG.fallingMin + rand()*(CONFIG.fallingMax - CONFIG.fallingMin);
  p.tone = Math.floor(rand()*3);  // 0/1/2
  p.alpha = 0.70 + rand()*0.25;

  // para que algunas caigan “desde fuera”
  if (rand() < 0.25) p.y = CAN.cy - CAN.R * 0.65 + rand()*30;
}

function buildFalling(){
  falling.length = 0;
  for (let i=0;i<CONFIG.fallingCount;i++){
    const p = {};
    spawnFalling(p);
    // offset inicial para que no caigan todas igual
    p.y += rand()*220;
    falling.push(p);
  }
}

/* =========================
   Build all
   ========================= */
function buildAll(){
  resize();
  buildCanopy();
  buildFalling();
}
buildAll();

window.addEventListener("resize", buildAll);
window.addEventListener("orientationchange", () => setTimeout(buildAll, 120));

/* =========================
   Animación principal
   ========================= */
let last = performance.now();
const t0 = performance.now();

function loop(now){
  const t = now - t0;
  const dt = Math.min(0.033, (now - last) / 1000);
  last = now;

  const W = canvas.getBoundingClientRect().width;
  const H = canvas.getBoundingClientRect().height;

  ctx.clearRect(0,0,W,H);

  // 1) Tronco base
  drawTrunkBase(t);

  // 2) Copa (corazones)
  for (const c of canopy){
    const lt = clamp((t - c.appear) / 850, 0, 1);
    if (lt <= 0) continue;

    const pop = easeOutBack(lt);
    const a = c.alpha * clamp(lt*1.25, 0, 1);
    const size = c.size * (0.35 + 0.65*pop);

    drawHeartPx(c.x, c.y, size, a, c.rot, c.tone);
  }

  // 3) Hojas cayendo (encima)
  // Empiezan cuando ya hay copa
  if (t > CONFIG.canopyStartMs + 300){
    for (const p of falling){
      // movimiento
      p.y += p.vy * dt;

      const x = p.x0 + Math.sin((now/1000)*Math.PI*2*p.freq + p.phase) * p.amp;
      p.rot += p.rotSpd * dt;

      // fade al final
      let a = p.alpha;
      if (p.y > H*0.82) a *= clamp(1 - (p.y - H*0.82)/(H*0.25), 0, 1);

      drawHeartPx(x, p.y, p.size, a, p.rot, p.tone);

      // respawn abajo
      if (p.y > H + 30){
        spawnFalling(p);
      }
    }
  }

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
